// Generated by CoffeeScript 1.9.0
var async, checkUpdate, chokidar, compiler, conf, convPath, cycleLock, cycler, defRoot, essay, evts, exec, extend, fs, index, indexer, make, path, source, uConf, uConfFile, watch, ydump, yml,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

exec = require('child_process').exec;

chokidar = require('chokidar');

async = require('async');

extend = require('extend');

yml = require('require-yml');

ydump = require('js-yaml').dump;

conf = require('../config');

source = path.join(process.cwd(), conf.dir.git);

essay = path.join(process.cwd(), conf.dir.essay);

uConfFile = path.resolve('Marbaf.yml');

uConf = yml(uConfFile);

if (uConf) {
  compiler = require('./compiler')(uConf);
}

defRoot = path.join(__dirname, '../deploy');

cycleLock = [];

index = {};

make = function(opts, force, cb) {
  return async.auto({
    makeTree: function(next) {
      var key, val, _ref;
      _ref = conf.dir;
      for (key in _ref) {
        val = _ref[key];
        if (!fs.existsSync(val)) {
          fs.mkdirSync(val);
        }
      }
      return exec(['cp', defRoot + '/* ./', '; cp -rf', defRoot + '/theme/* ' + conf.dir.theme].join(' '), next);
    },
    gitClone: function(next) {
      if (fs.existsSync(source) && fs.existsSync(source + '/.git/config')) {
        return next();
      }
      return exec(['git clone', opts.repo, source].join(' '), next);
    },
    makeConf: [
      'makeTree', function(next) {
        if (!uConf || force) {
          uConf = yml(uConfFile);
        }
        uConf = extend(uConf, optsx);
        return fs.writeFile(uConfFile, ydump(uConf), next);
      }
    ]
  }, cb);
};

indexer = function(indexId, reindex, desc) {
  console.log(indexId, 'haha...');
  return function(err) {
    if (err) {
      delete index[indexId];
    }
    return cycleLock.pop();
  };
};

cycler = function() {
  if (cycleLock.length) {
    return setTimeout(cycler, conf.cycleTimeAwait);
  }
  return exec('cd ' + source + '; git pull origin', function(err) {
    if (err) {
      throw err;
    }
    return cycler(source);
  });
};

convPath = function(_path) {
  return _path.replace(source, essay);
};

evts = ['unlink', 'unlinkDir', 'addDir', 'add', 'change'];

checkUpdate = function(evt, name) {
  var suffix, target;
  if (__indexOf.call(evts, evt) < 0) {
    return;
  }
  cycleLock.push(1);
  switch (evt) {
    case 'unlink':
    case 'unlinkDir':
      return exec('rm -rf ' + convPath(name), indexer(name, true));
    case 'addDir':
      return exec('mkdir -p ' + convPath(name), indexer(name));
    case 'add':
    case 'change':
      suffix = path.extname(name);
      target = convPath(name);
      if (suffix === '.md') {
        target = target.replace(suffix, '.html').replace('README', 'index');
        return compiler.essay(name, function(err, essay) {
          if (err) {
            return console.error(err);
          }
          fs.writeFile(target, essay);
          return indexer(target, true);
        });
      } else {
        return exec('cp -f ' + name, indexer(name, true));
      }
  }
};

watch = function() {
  var opts;
  opts = {
    ignored: /[\/\\]\./
  };
  chokidar.watch(source, opts).on('all', checkUpdate);
  return cycler();
};

module.exports = function(force) {
  return {
    init: function(repo, name, desc) {
      console.info('Pending...');
      return make({
        repo: repo,
        name: name,
        description: desc
      }, force, function() {}, console.info('Init successed.\nYou can continue to run: `marbaf start` in current directory now.'));
    },
    start: function() {
      return watch();
    }
  };
};
